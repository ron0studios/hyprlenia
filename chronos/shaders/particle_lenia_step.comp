#version 460 core

/*
 * CHRONOS - Particle Lenia with Food-Based Evolution
 *
 * Based on the standard Particle Lenia formulation:
 * - U(x) = Σ K(||x - p_i||) where K is a Gaussian shell kernel
 * - G(U) = exp(-(U - μ_G)² / σ_G²) is the growth function
 * - R(x) = (c_rep/2) Σ max(1 - ||x - p_i||, 0)² is repulsion
 * - E(x) = R(x) - G(U(x)) is the energy field
 * - Particles move down the energy gradient: dx/dt = -∇E
 *
 * FOOD SYSTEM:
 * - Particles gain energy by consuming food from the environment
 * - Particles in clusters can reproduce when energy is high
 * - No random birth rate - only reproduction from existing particles
 * - Particles die from starvation (low energy) or old age
 */

layout(local_size_x = 128) in;

layout(std430, binding = 0) readonly buffer ParticlesIn {
  float particlesIn[];
};

layout(std430, binding = 1) buffer ParticlesOut { float particlesOut[]; };

// Food texture - read/write for consumption
layout(rgba16f, binding = 0) uniform image2D u_FoodTexture;

// Shared memory for particle data
shared vec4 tileData[128];  // xy = position, z = energy

uniform int u_NumParticles;
uniform int u_AliveCount;
uniform float u_WorldWidth;
uniform float u_WorldHeight;
uniform float u_Wk;       // Kernel weight
uniform float u_MuK;      // Kernel peak distance
uniform float u_SigmaK2;  // Kernel width squared
uniform float u_MuG;      // Growth target density
uniform float u_SigmaG2;  // Growth width squared
uniform float u_Crep;     // Repulsion strength
uniform float u_Dt;       // Time step
uniform float u_H;        // Finite difference step size
uniform bool u_EvolutionEnabled;
uniform float u_BirthRate;        // Now used as reproduction threshold modifier
uniform float u_DeathRate;        // Starvation death rate
uniform float u_MutationRate;
uniform float u_EnergyDecay;      // Base energy decay per step
uniform float u_EnergyFromGrowth; // Energy gained from food (consumption rate)
uniform int u_RandomSeed;

// Food system uniforms
uniform int u_FoodGridSize;
uniform float u_FoodConsumptionRadius;  // How far particles can reach for food

// Convert world position to food texture coordinates
ivec2 worldToFoodTexel(vec2 worldPos) {
  // World goes from -width/2 to +width/2
  // Map to 0-1, then to 0-gridSize
  vec2 uv = (worldPos + vec2(u_WorldWidth, u_WorldHeight) * 0.5) / vec2(u_WorldWidth, u_WorldHeight);
  uv = clamp(uv, 0.0, 0.999);
  return ivec2(uv * float(u_FoodGridSize));
}

// Sample and consume food at a position, returns amount consumed
float consumeFood(vec2 worldPos, float maxConsume) {
  ivec2 texel = worldToFoodTexel(worldPos);
  vec4 food = imageLoad(u_FoodTexture, texel);
  float available = food.r;
  float consumed = min(available, maxConsume);
  
  // Reduce food in the texture
  if (consumed > 0.001) {
    food.r = available - consumed;
    imageStore(u_FoodTexture, texel, food);
  }
  
  return consumed;
}

// Get food amount at position without consuming
float sampleFood(vec2 worldPos) {
  ivec2 texel = worldToFoodTexel(worldPos);
  return imageLoad(u_FoodTexture, texel).r;
}

// Wrap delta for toroidal world
// World goes from -worldWidth/2 to +worldWidth/2 (total size = worldWidth)
vec2 wrappedDelta(vec2 from, vec2 to) {
  vec2 d = to - from;
  float halfW = u_WorldWidth * 0.5;
  float halfH = u_WorldHeight * 0.5;
  if (d.x > halfW)
    d.x -= u_WorldWidth;
  else if (d.x < -halfW)
    d.x += u_WorldWidth;
  if (d.y > halfH)
    d.y -= u_WorldHeight;
  else if (d.y < -halfH)
    d.y += u_WorldHeight;
  return d;
}

vec2 wrapPos(vec2 pos) {
  float halfW = u_WorldWidth * 0.5;
  float halfH = u_WorldHeight * 0.5;
  pos.x = mod(pos.x + halfW, u_WorldWidth) - halfW;
  pos.y = mod(pos.y + halfH, u_WorldHeight) - halfH;
  return pos;
}

float hash(int seed) {
  int x = seed;
  x = ((x >> 16) ^ x) * 0x45d9f3b;
  x = ((x >> 16) ^ x) * 0x45d9f3b;
  x = (x >> 16) ^ x;
  return float(x & 0x7FFFFFFF) / float(0x7FFFFFFF);
}

float random(int idx, int offset) {
  return hash(idx * 1337 + offset * 7919 + u_RandomSeed * 104729);
}

// Kernel function K(r) - Gaussian shell at distance μ_k
float kernelK(float r) {
  float diff = r - u_MuK;
  return u_Wk * exp(-diff * diff / u_SigmaK2);
}

// Compute U and R fields at a given position from the current tile
vec2 computeUR(vec2 queryPos, int tileEnd) {
  float U = 0.0;
  float R = 0.0;

  for (int j = 0; j < tileEnd; j++) {
    float otherEnergy = tileData[j].z;
    if (otherEnergy < 0.01) continue;

    vec2 otherPos = tileData[j].xy;
    vec2 delta = wrappedDelta(queryPos, otherPos);
    float dist = length(delta);

    // Kernel contribution to U
    U += kernelK(dist);

    // Repulsion contribution to R
    if (dist > 0.0001 && dist < 1.0) {
      float proximity = 1.0 - dist;
      R += 0.5 * u_Crep * proximity * proximity;
    }
  }

  return vec2(U, R);
}

// Compute energy E = R - G(U)
float computeE(float U, float R) {
  float diff = U - u_MuG;
  float G = exp(-diff * diff / u_SigmaG2);
  return R - G;
}

void main() {
  uint idx = gl_GlobalInvocationID.x;
  uint localIdx = gl_LocalInvocationID.x;

  if (idx >= u_NumParticles) return;

  int i = int(idx);
  int base = i * 12;

  // Read my particle data
  vec2 myPos = vec2(particlesIn[base], particlesIn[base + 1]);
  vec2 myVel = vec2(particlesIn[base + 2], particlesIn[base + 3]);
  float myEnergy = particlesIn[base + 4];
  float mySpecies = particlesIn[base + 5];
  float myAge = particlesIn[base + 6];
  float myDna[5];
  for (int d = 0; d < 5; d++) {
    myDna[d] = particlesIn[base + 7 + d];
  }

  // Dead particles stay dead
  if (myEnergy < 0.01) {
    for (int j = 0; j < 12; j++) {
      particlesOut[base + j] = particlesIn[base + j];
    }
    return;
  }

  // Finite difference positions
  float h = u_H;
  vec2 posXp = myPos + vec2(h, 0.0);
  vec2 posXn = myPos - vec2(h, 0.0);
  vec2 posYp = myPos + vec2(0.0, h);
  vec2 posYn = myPos - vec2(0.0, h);

  // Accumulators for fields at 5 positions (center + 4 for gradient)
  vec2 UR_c = vec2(0.0);   // center
  vec2 UR_xp = vec2(0.0);  // x+h
  vec2 UR_xn = vec2(0.0);  // x-h
  vec2 UR_yp = vec2(0.0);  // y+h
  vec2 UR_yn = vec2(0.0);  // y-h

  int numTiles = (u_NumParticles + 127) / 128;

  for (int t = 0; t < numTiles; t++) {
    // Collaborative load
    int loadIdx = t * 128 + int(localIdx);
    if (loadIdx < u_NumParticles) {
      int loadBase = loadIdx * 12;
      tileData[localIdx] = vec4(particlesIn[loadBase],      // x
                                particlesIn[loadBase + 1],  // y
                                particlesIn[loadBase + 4],  // energy
                                0.0);
    } else {
      tileData[localIdx] = vec4(0.0);
    }

    barrier();

    int tileEnd = min(128, u_NumParticles - t * 128);

    // Compute U and R at all 5 positions
    UR_c += computeUR(myPos, tileEnd);
    UR_xp += computeUR(posXp, tileEnd);
    UR_xn += computeUR(posXn, tileEnd);
    UR_yp += computeUR(posYp, tileEnd);
    UR_yn += computeUR(posYn, tileEnd);

    barrier();
  }

  // Compute energy at each position: E = R - G(U)
  float E_xp = computeE(UR_xp.x, UR_xp.y);
  float E_xn = computeE(UR_xn.x, UR_xn.y);
  float E_yp = computeE(UR_yp.x, UR_yp.y);
  float E_yn = computeE(UR_yn.x, UR_yn.y);

  // Central difference gradient
  float h2 = 2.0 * h;
  vec2 gradE = vec2((E_xp - E_xn) / h2, (E_yp - E_yn) / h2);

  // Growth value at center (for evolution)
  float diff = UR_c.x - u_MuG;
  float growth = exp(-diff * diff / u_SigmaG2);

  // Update position: move against gradient
  vec2 newPos = myPos - u_Dt * gradE;
  newPos = wrapPos(newPos);

  // Update velocity
  myVel = (newPos - myPos) / max(u_Dt, 0.001);
  myPos = newPos;
  myAge += 1.0;

  // Evolution mechanics - FOOD-BASED SURVIVAL
  if (u_EvolutionEnabled) {
    // === FOOD CONSUMPTION ===
    // Particles consume food near them to gain energy
    float foodConsumed = consumeFood(myPos, u_EnergyFromGrowth * 0.5);
    
    // Cluster bonus: particles in groups are more efficient at finding food
    // Higher neighbor density means better foraging (growth reflects local density)
    float clusterBonus = growth * 0.3;  // 0-30% bonus based on neighbors
    float energyGain = foodConsumed * (1.0 + clusterBonus);
    
    // === ENERGY DECAY ===
    // Constant energy drain - particles must keep finding food
    float energyLoss = u_EnergyDecay;

    // Age-based senescence (very gentle, starts at old age)
    if (myAge > 3000.0) {
      energyLoss += u_DeathRate * 0.05 * (myAge - 3000.0) / 3000.0;
    }
    
    // Isolation penalty: particles alone lose energy faster
    if (growth < 0.2) {
      energyLoss += u_EnergyDecay * 0.5;  // 50% more decay when isolated
    }

    // Net energy change
    myEnergy = clamp(myEnergy + energyGain - energyLoss, 0.0, 1.0);

    // === STARVATION DEATH ===
    // Die if energy fully depleted
    if (myEnergy < 0.001) {
      myEnergy = 0.0;  // Mark as dead
    }

    // === REPRODUCTION ===
    // Only way to create new particles: high-energy particles reproduce
    // REQUIRES: sufficient energy AND recent food consumption
    // This ensures reproduction only happens in food-rich areas
    if (myEnergy > 0.80 && foodConsumed > 0.001) {
      // Higher reproduction chance when very well-fed and actively eating
      float reproChance = (myEnergy - 0.80) * 0.5 * min(foodConsumed * 10.0, 1.0);
      
      if (random(i, 1) < reproChance) {
        // Find a dead particle slot to spawn into
        for (int j = 0; j < u_NumParticles; j++) {
          float otherE = particlesIn[j * 12 + 4];
          if (otherE < 0.01) {
            int childBase = j * 12;
            float angle = random(i, 2) * 6.28318;
            float spawnDist = 0.5 + random(i, 3) * 0.5;
            vec2 childPos =
                wrapPos(myPos + vec2(cos(angle), sin(angle)) * spawnDist);

            particlesOut[childBase + 0] = childPos.x;
            particlesOut[childBase + 1] = childPos.y;
            particlesOut[childBase + 2] = myVel.x * 0.5;  // Inherit some momentum
            particlesOut[childBase + 3] = myVel.y * 0.5;
            particlesOut[childBase + 4] = 0.35;  // Child starts with moderate energy
            particlesOut[childBase + 5] = mySpecies + (random(i, 4) - 0.5) * 0.1;
            particlesOut[childBase + 6] = 0.0;

            for (int d = 0; d < 5; d++) {
              float mut = (random(i, 5 + d) - 0.5) * u_MutationRate;
              particlesOut[childBase + 7 + d] = clamp(myDna[d] + mut, -0.5, 0.5);
            }

            myEnergy -= 0.35;  // Cost of reproduction (substantial)
            break;
          }
        }
      }
    }
  }

  // Write output
  particlesOut[base + 0] = myPos.x;
  particlesOut[base + 1] = myPos.y;
  particlesOut[base + 2] = myVel.x;
  particlesOut[base + 3] = myVel.y;
  particlesOut[base + 4] = myEnergy;
  particlesOut[base + 5] = mySpecies;
  particlesOut[base + 6] = myAge;
  for (int d = 0; d < 5; d++) {
    particlesOut[base + 7 + d] = myDna[d];
  }
}
