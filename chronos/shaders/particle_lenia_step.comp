#version 460 core

/*
 * CHRONOS - 3D Multi-Channel Particle Lenia with Food-Based Evolution
 *
 * Extended to support 2 channels with cross-channel interactions:
 * - Each channel has its own kernel (μ_k, σ_k²) and growth (μ_g, σ_g²) params
 * - Interaction matrix controls how channels affect each other's growth
 * - U(x) is now split by source channel: U0, U1
 * - Effective U for channel c: U_eff = Σ interaction[from][c] * U_from
 *
 * Particle layout (14 floats):
 *   0-2: position (x, y, z)
 *   3-5: velocity (vx, vy, vz)
 *   6: energy
 *   7: channel (0 or 1)
 *   8: age
 *   9-13: dna[5]
 */

layout(local_size_x = 128) in;

layout(std430, binding = 0) readonly buffer ParticlesIn {
  float particlesIn[];
};

layout(std430, binding = 1) buffer ParticlesOut { float particlesOut[]; };

// Food texture - read/write for consumption
layout(rgba16f, binding = 0) uniform image2D u_FoodTexture;

// Shared memory for particle data (3D position + energy + channel)
shared vec4 tileData[128];     // xyz = position, w = energy
shared float tileChannel[128]; // channel (0 or 1)

uniform int u_NumParticles;
uniform int u_AliveCount;
uniform float u_WorldWidth;
uniform float u_WorldHeight;
uniform float u_WorldDepth;
uniform float u_Wk;       // Kernel weight (global)
uniform float u_MuK;      // Kernel peak distance (legacy, unused in multi-channel)
uniform float u_SigmaK2;  // Kernel width squared (legacy, unused in multi-channel)
uniform float u_MuG;      // Growth target density (legacy, unused in multi-channel)
uniform float u_SigmaG2;  // Growth width squared (legacy, unused in multi-channel)
uniform float u_Crep;     // Repulsion strength
uniform float u_Dt;       // Time step
uniform float u_H;        // Finite difference step size
uniform bool u_EvolutionEnabled;
uniform float u_BirthRate;
uniform float u_DeathRate;
uniform float u_MutationRate;
uniform float u_EnergyDecay;
uniform float u_EnergyFromGrowth;
uniform int u_RandomSeed;

// Food system uniforms
uniform int u_FoodGridSize;
uniform float u_FoodConsumptionRadius;

// Multi-channel uniforms
uniform float u_MuK_Ch[2];      // Per-channel kernel peak distance
uniform float u_SigmaK2_Ch[2];  // Per-channel kernel width squared
uniform float u_MuG_Ch[2];      // Per-channel growth target density
uniform float u_SigmaG2_Ch[2];  // Per-channel growth width squared
uniform float u_Interaction[4]; // Interaction matrix [from * 2 + to]

// Convert world position to food texture coordinates (XY plane projection)
ivec2 worldToFoodTexel(vec3 worldPos) {
  vec2 uv = (worldPos.xy + vec2(u_WorldWidth, u_WorldHeight) * 0.5) / vec2(u_WorldWidth, u_WorldHeight);
  uv = clamp(uv, 0.0, 0.999);
  return ivec2(uv * float(u_FoodGridSize));
}

// Sample and consume food at a position, returns amount consumed
float consumeFood(vec3 worldPos, float maxConsume) {
  ivec2 texel = worldToFoodTexel(worldPos);
  vec4 food = imageLoad(u_FoodTexture, texel);
  float available = food.r;
  float consumed = min(available, maxConsume);

  if (consumed > 0.001) {
    food.r = available - consumed;
    imageStore(u_FoodTexture, texel, food);
  }

  return consumed;
}

// Get food amount at position without consuming
float sampleFood(vec3 worldPos) {
  ivec2 texel = worldToFoodTexel(worldPos);
  return imageLoad(u_FoodTexture, texel).r;
}

// Wrap delta for toroidal 3D world
vec3 wrappedDelta(vec3 from, vec3 to) {
  vec3 d = to - from;
  float halfW = u_WorldWidth * 0.5;
  float halfH = u_WorldHeight * 0.5;
  float halfD = u_WorldDepth * 0.5;

  if (d.x > halfW) d.x -= u_WorldWidth;
  else if (d.x < -halfW) d.x += u_WorldWidth;

  if (d.y > halfH) d.y -= u_WorldHeight;
  else if (d.y < -halfH) d.y += u_WorldHeight;

  if (d.z > halfD) d.z -= u_WorldDepth;
  else if (d.z < -halfD) d.z += u_WorldDepth;

  return d;
}

vec3 wrapPos(vec3 pos) {
  float halfW = u_WorldWidth * 0.5;
  float halfH = u_WorldHeight * 0.5;
  float halfD = u_WorldDepth * 0.5;

  pos.x = mod(pos.x + halfW, u_WorldWidth) - halfW;
  pos.y = mod(pos.y + halfH, u_WorldHeight) - halfH;
  pos.z = mod(pos.z + halfD, u_WorldDepth) - halfD;

  return pos;
}

float hash(int seed) {
  int x = seed;
  x = ((x >> 16) ^ x) * 0x45d9f3b;
  x = ((x >> 16) ^ x) * 0x45d9f3b;
  x = (x >> 16) ^ x;
  return float(x & 0x7FFFFFFF) / float(0x7FFFFFFF);
}

float random(int idx, int offset) {
  return hash(idx * 1337 + offset * 7919 + u_RandomSeed * 104729);
}

// Kernel function K(r) for a specific source channel
float kernelK(float r, int sourceChannel) {
  float mu = u_MuK_Ch[sourceChannel];
  float sigma2 = u_SigmaK2_Ch[sourceChannel];
  float diff = r - mu;
  return u_Wk * exp(-diff * diff / sigma2);
}

// Compute U per source channel and R at a given 3D position from the current tile
// Returns vec3: x = U from channel 0, y = U from channel 1, z = R (repulsion)
vec3 computeU_PerChannel_R(vec3 queryPos, int tileEnd) {
  vec2 U = vec2(0.0);  // U.x = from channel 0, U.y = from channel 1
  float R = 0.0;

  for (int j = 0; j < tileEnd; j++) {
    float otherEnergy = tileData[j].w;
    if (otherEnergy < 0.01) continue;

    vec3 otherPos = tileData[j].xyz;
    int otherChannel = int(tileChannel[j]);

    vec3 delta = wrappedDelta(queryPos, otherPos);
    float dist = length(delta);

    // Kernel contribution separated by source channel
    float k = kernelK(dist, otherChannel);
    if (otherChannel == 0) {
      U.x += k;
    } else {
      U.y += k;
    }

    // Repulsion contribution to R (channel-independent)
    if (dist > 0.0001 && dist < 1.0) {
      float proximity = 1.0 - dist;
      R += 0.5 * u_Crep * proximity * proximity;
    }
  }

  return vec3(U.x, U.y, R);
}

// Compute effective U for a particle based on its channel using interaction matrix
float computeEffectiveU(vec2 U_perChannel, int myChannel) {
  // interaction[from * 2 + to]: how much channel 'from' affects channel 'to'
  return u_Interaction[0 * 2 + myChannel] * U_perChannel.x +
         u_Interaction[1 * 2 + myChannel] * U_perChannel.y;
}

// Compute growth G for a specific channel
float computeG(float effectiveU, int myChannel) {
  float mu = u_MuG_Ch[myChannel];
  float sigma2 = u_SigmaG2_Ch[myChannel];
  float diff = effectiveU - mu;
  return exp(-diff * diff / sigma2);
}

// Compute energy E = R - G(U_eff) for a specific channel
float computeE(vec2 U_perChannel, float R, int myChannel) {
  float U_eff = computeEffectiveU(U_perChannel, myChannel);
  float G = computeG(U_eff, myChannel);
  return R - G;
}

void main() {
  uint idx = gl_GlobalInvocationID.x;
  uint localIdx = gl_LocalInvocationID.x;

  if (idx >= u_NumParticles) return;

  int i = int(idx);
  int base = i * 14;  // 14 floats per particle

  // Read my particle data (3D)
  vec3 myPos = vec3(particlesIn[base], particlesIn[base + 1], particlesIn[base + 2]);
  vec3 myVel = vec3(particlesIn[base + 3], particlesIn[base + 4], particlesIn[base + 5]);
  float myEnergy = particlesIn[base + 6];
  int myChannel = int(particlesIn[base + 7]);  // Channel 0 or 1
  float myAge = particlesIn[base + 8];
  float myDna[5];
  for (int d = 0; d < 5; d++) {
    myDna[d] = particlesIn[base + 9 + d];
  }

  // Dead particles stay dead
  if (myEnergy < 0.01) {
    for (int j = 0; j < 14; j++) {
      particlesOut[base + j] = particlesIn[base + j];
    }
    return;
  }

  // Finite difference positions for 3D gradient (6 neighbors + center)
  float h = u_H;
  vec3 posXp = myPos + vec3(h, 0.0, 0.0);
  vec3 posXn = myPos - vec3(h, 0.0, 0.0);
  vec3 posYp = myPos + vec3(0.0, h, 0.0);
  vec3 posYn = myPos - vec3(0.0, h, 0.0);
  vec3 posZp = myPos + vec3(0.0, 0.0, h);
  vec3 posZn = myPos - vec3(0.0, 0.0, h);

  // Accumulators for fields at 7 positions (center + 6 for gradient)
  // vec3: x = U from ch0, y = U from ch1, z = R
  vec3 UR_c = vec3(0.0);   // center
  vec3 UR_xp = vec3(0.0);  // x+h
  vec3 UR_xn = vec3(0.0);  // x-h
  vec3 UR_yp = vec3(0.0);  // y+h
  vec3 UR_yn = vec3(0.0);  // y-h
  vec3 UR_zp = vec3(0.0);  // z+h
  vec3 UR_zn = vec3(0.0);  // z-h

  int numTiles = (u_NumParticles + 127) / 128;

  for (int t = 0; t < numTiles; t++) {
    // Collaborative load (3D position + energy + channel)
    int loadIdx = t * 128 + int(localIdx);
    if (loadIdx < u_NumParticles) {
      int loadBase = loadIdx * 14;
      tileData[localIdx] = vec4(particlesIn[loadBase],      // x
                                particlesIn[loadBase + 1],  // y
                                particlesIn[loadBase + 2],  // z
                                particlesIn[loadBase + 6]); // energy
      tileChannel[localIdx] = particlesIn[loadBase + 7];    // channel
    } else {
      tileData[localIdx] = vec4(0.0);
      tileChannel[localIdx] = 0.0;
    }

    barrier();

    int tileEnd = min(128, u_NumParticles - t * 128);

    // Compute U per channel and R at all 7 positions
    UR_c += computeU_PerChannel_R(myPos, tileEnd);
    UR_xp += computeU_PerChannel_R(posXp, tileEnd);
    UR_xn += computeU_PerChannel_R(posXn, tileEnd);
    UR_yp += computeU_PerChannel_R(posYp, tileEnd);
    UR_yn += computeU_PerChannel_R(posYn, tileEnd);
    UR_zp += computeU_PerChannel_R(posZp, tileEnd);
    UR_zn += computeU_PerChannel_R(posZn, tileEnd);

    barrier();
  }

  // Compute energy at each position using my channel's parameters
  float E_xp = computeE(UR_xp.xy, UR_xp.z, myChannel);
  float E_xn = computeE(UR_xn.xy, UR_xn.z, myChannel);
  float E_yp = computeE(UR_yp.xy, UR_yp.z, myChannel);
  float E_yn = computeE(UR_yn.xy, UR_yn.z, myChannel);
  float E_zp = computeE(UR_zp.xy, UR_zp.z, myChannel);
  float E_zn = computeE(UR_zn.xy, UR_zn.z, myChannel);

  // Central difference gradient (3D)
  float h2 = 2.0 * h;
  vec3 gradE = vec3(
    (E_xp - E_xn) / h2,
    (E_yp - E_yn) / h2,
    (E_zp - E_zn) / h2
  );

  // Growth value at center (for evolution) - using my channel's params
  float U_eff_center = computeEffectiveU(UR_c.xy, myChannel);
  float growth = computeG(U_eff_center, myChannel);

  // Update position: move against gradient (3D)
  vec3 newPos = myPos - u_Dt * gradE;
  newPos = wrapPos(newPos);

  // Update velocity (3D)
  myVel = (newPos - myPos) / max(u_Dt, 0.001);
  myPos = newPos;
  myAge += 1.0;

  // Evolution mechanics - FOOD-BASED SURVIVAL
  if (u_EvolutionEnabled) {
    // === FOOD CONSUMPTION ===
    float foodConsumed = consumeFood(myPos, u_EnergyFromGrowth * 0.5);

    // Cluster bonus
    float clusterBonus = growth * 0.3;
    float energyGain = foodConsumed * (1.0 + clusterBonus);

    // === ENERGY DECAY ===
    float energyLoss = u_EnergyDecay;

    // Age-based senescence
    if (myAge > 3000.0) {
      energyLoss += u_DeathRate * 0.05 * (myAge - 3000.0) / 3000.0;
    }

    // Isolation penalty
    if (growth < 0.2) {
      energyLoss += u_EnergyDecay * 0.5;
    }

    // Net energy change
    myEnergy = clamp(myEnergy + energyGain - energyLoss, 0.0, 1.0);

    // === STARVATION DEATH ===
    if (myEnergy < 0.001) {
      myEnergy = 0.0;
    }

    // === REPRODUCTION ===
    if (myEnergy > 0.80 && foodConsumed > 0.001) {
      float reproChance = (myEnergy - 0.80) * 0.5 * min(foodConsumed * 10.0, 1.0);

      if (random(i, 1) < reproChance) {
        for (int j = 0; j < u_NumParticles; j++) {
          float otherE = particlesIn[j * 14 + 6];
          if (otherE < 0.01) {
            int childBase = j * 14;

            // Random direction in 3D (spherical)
            float theta = random(i, 2) * 6.28318;  // azimuth
            float phi = acos(2.0 * random(i, 3) - 1.0);  // polar
            float spawnDist = 0.5 + random(i, 4) * 0.5;

            vec3 spawnDir = vec3(
              sin(phi) * cos(theta),
              sin(phi) * sin(theta),
              cos(phi)
            );
            vec3 childPos = wrapPos(myPos + spawnDir * spawnDist);

            particlesOut[childBase + 0] = childPos.x;
            particlesOut[childBase + 1] = childPos.y;
            particlesOut[childBase + 2] = childPos.z;
            particlesOut[childBase + 3] = myVel.x * 0.5;
            particlesOut[childBase + 4] = myVel.y * 0.5;
            particlesOut[childBase + 5] = myVel.z * 0.5;
            particlesOut[childBase + 6] = 0.35;
            particlesOut[childBase + 7] = float(myChannel);  // Child inherits parent's channel
            particlesOut[childBase + 8] = 0.0;

            for (int d = 0; d < 5; d++) {
              float mut = (random(i, 6 + d) - 0.5) * u_MutationRate;
              particlesOut[childBase + 9 + d] = clamp(myDna[d] + mut, -0.5, 0.5);
            }

            myEnergy -= 0.35;
            break;
          }
        }
      }
    }
  }

  // Write output (14 floats)
  particlesOut[base + 0] = myPos.x;
  particlesOut[base + 1] = myPos.y;
  particlesOut[base + 2] = myPos.z;
  particlesOut[base + 3] = myVel.x;
  particlesOut[base + 4] = myVel.y;
  particlesOut[base + 5] = myVel.z;
  particlesOut[base + 6] = myEnergy;
  particlesOut[base + 7] = float(myChannel);  // Preserve channel
  particlesOut[base + 8] = myAge;
  for (int d = 0; d < 5; d++) {
    particlesOut[base + 9 + d] = myDna[d];
  }
}
