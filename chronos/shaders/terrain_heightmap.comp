#version 450 core

/*
 * Terrain Heightmap Generator
 * 
 * Computes a heightmap from particle field density.
 * Uses a lower resolution for performance (e.g., 128x128).
 * Applies smoothing for a nice visual appearance.
 */

layout(local_size_x = 16, local_size_y = 16) in;

layout(rgba16f, binding = 0) writeonly uniform image2D u_Heightmap;

layout(std430, binding = 0) readonly buffer Particles {
    float particles[];
};

uniform int u_NumParticles;
uniform int u_HeightmapSize;
uniform float u_WorldWidth;
uniform float u_WorldHeight;
uniform float u_MuK;
uniform float u_SigmaK2;
uniform float u_Wk;

#define READ_PARTICLE_POS(i) vec2(particles[(i) * 12], particles[(i) * 12 + 1])
#define READ_PARTICLE_ENERGY(i) particles[(i) * 12 + 4]
#define READ_PARTICLE_SPECIES(i) particles[(i) * 12 + 5]

// Wrapped distance for toroidal world
float wrappedDist(vec2 pos1, vec2 pos2) {
    vec2 d = pos2 - pos1;
    float halfW = u_WorldWidth * 0.5;
    float halfH = u_WorldHeight * 0.5;
    if (d.x > halfW) d.x -= u_WorldWidth;
    else if (d.x < -halfW) d.x += u_WorldWidth;
    if (d.y > halfH) d.y -= u_WorldHeight;
    else if (d.y < -halfH) d.y += u_WorldHeight;
    return length(d);
}

void main() {
    ivec2 texel = ivec2(gl_GlobalInvocationID.xy);
    if (texel.x >= u_HeightmapSize || texel.y >= u_HeightmapSize) return;
    
    // Map texel to world position
    vec2 uv = (vec2(texel) + 0.5) / float(u_HeightmapSize);
    vec2 worldPos = vec2(
        (uv.x - 0.5) * u_WorldWidth,
        (uv.y - 0.5) * u_WorldHeight
    );
    
    // Compute field density at this position
    float density = 0.0;
    float closestDist = 1000.0;
    float closestEnergy = 0.0;
    float closestSpecies = 0.0;
    
    float cutoff = u_MuK + 3.0 * sqrt(u_SigmaK2);
    float invSigmaK2 = 1.0 / u_SigmaK2;
    
    // Sample particles (with step for performance)
    int step = max(1, u_NumParticles / 500);
    
    for (int i = 0; i < u_NumParticles; i += step) {
        float energy = READ_PARTICLE_ENERGY(i);
        if (energy < 0.01) continue;
        
        vec2 ppos = READ_PARTICLE_POS(i);
        float dist = wrappedDist(worldPos, ppos);
        
        if (dist < cutoff) {
            float r_diff = dist - u_MuK;
            float kernel = u_Wk * exp(-r_diff * r_diff * invSigmaK2);
            density += kernel * energy * float(step);
        }
        
        if (dist < closestDist) {
            closestDist = dist;
            closestEnergy = energy;
            closestSpecies = READ_PARTICLE_SPECIES(i);
        }
    }
    
    // Height based on density with soft falloff (normalized 0-1)
    float height = min(density * 2.0, 1.0);
    
    // Add particle proximity contribution
    float particleHeight = exp(-closestDist * 2.0) * closestEnergy * 0.5;
    height = min(height + particleHeight, 1.0);
    
    // Store: R = height, G = density, B = closest species, A = closest energy
    imageStore(u_Heightmap, texel, vec4(height, density, closestSpecies / 3.0, closestEnergy));
}
