#version 450 core
/*
 * CHRONOS - Ultra-Optimized Particle Lenia
 *
 * Key optimizations:
 * 1. ANALYTICAL gradient (no finite differences - 5x faster)
 * 2. Shared memory tiling for particle data
 * 3. Early distance culling
 * 4. Fused field + gradient computation in single pass
 */

layout(local_size_x = 128) in;

// === PARTICLE DATA STRUCTURE ===
struct Particle {
  vec2 pos;
  vec2 vel;
  float mass;
  float species;
  vec2 padding;
};

layout(std430, binding = 0) readonly buffer ParticleInput {
  Particle particles[];
};

layout(std430, binding = 1) writeonly buffer ParticleOutput {
  Particle particlesOut[];
};

// Shared memory tile for particle positions and masses
shared vec4 tile[128];  // xy = pos, z = mass, w = unused

uniform int u_NumParticles;
uniform float u_Time;
uniform float u_DeltaTime;
uniform float u_Wk;
uniform float u_MuK;
uniform float u_SigmaK2;
uniform float u_MuG;
uniform float u_SigmaG2;
uniform float u_Crep;
uniform float u_Dt;
uniform float u_WorldSize;

// Toroidal wrap
vec2 wrap(vec2 delta, float size) {
  return mod(delta + size, 2.0 * size) - size;
}

void main() {
  uint idx = gl_GlobalInvocationID.x;
  uint localIdx = gl_LocalInvocationID.x;

  // Load current particle
  bool active = idx < u_NumParticles;
  Particle p;
  vec2 myPos = vec2(0.0);
  float myMass = 0.0;

  if (active) {
    p = particles[idx];
    myPos = p.pos;
    myMass = p.mass;
  }

  // Skip if dead
  if (!active || myMass < 0.01) {
    if (active) particlesOut[idx] = p;
    return;
  }

  // Precompute inverses
  float invSigmaK2 = 1.0 / u_SigmaK2;
  float invSigmaG2 = 1.0 / u_SigmaG2;

  // Accumulators for field AND gradient in single pass
  float density = 0.0;
  float separation = 0.0;
  vec2 densityGrad = vec2(0.0);
  vec2 separationGrad = vec2(0.0);

  // Cutoff distances for early culling
  float kernelCutoff = u_MuK + 3.0 * sqrt(u_SigmaK2);
  float repulsionCutoff = 1.0;
  float maxCutoff = max(kernelCutoff, repulsionCutoff);
  float maxCutoff2 = maxCutoff * maxCutoff;

  // Tile-based processing with shared memory
  int numTiles = (u_NumParticles + 127) / 128;

  for (int t = 0; t < numTiles; t++) {
    // Collaborative load into shared memory
    int loadIdx = t * 128 + int(localIdx);
    if (loadIdx < u_NumParticles) {
      Particle other = particles[loadIdx];
      tile[localIdx] = vec4(other.pos, other.mass, 0.0);
    } else {
      tile[localIdx] = vec4(0.0, 0.0, 0.0, 0.0);
    }

    barrier();

    // Process tile
    int tileEnd = min(128, u_NumParticles - t * 128);
    for (int j = 0; j < tileEnd; j++) {
      int otherIdx = t * 128 + j;

      vec4 other = tile[j];
      if (other.z < 0.01) continue;  // Skip dead

      vec2 delta = wrap(other.xy - myPos, u_WorldSize);
      float dist2 = dot(delta, delta);

      // Early culling
      if (dist2 > maxCutoff2) continue;

      float dist = sqrt(dist2);
      vec2 dir = dist > 0.0001 ? delta / dist : vec2(0.0);

      // === KERNEL CONTRIBUTION ===
      float r_diff = dist - u_MuK;
      float kernelVal = u_Wk * exp(-r_diff * r_diff * invSigmaK2);
      float massWeighted = kernelVal * other.z;
      density += massWeighted;

      // Analytical gradient: dK/dr * dr/dx
      float kernelGradMag = massWeighted * (-2.0 * r_diff * invSigmaK2);
      densityGrad += kernelGradMag * dir;

      // === SEPARATION CONTRIBUTION ===
      if (otherIdx != int(idx) && dist > 0.0001 && dist < repulsionCutoff) {
        float proximity = 1.0 - dist;
        separation += u_Crep * 0.5 * proximity * proximity;
        separationGrad += (-u_Crep * proximity) * dir;
      }
    }

    barrier();
  }

  // === COHESION FROM DENSITY ===
  float u_diff = density - u_MuG;
  float cohesion = exp(-u_diff * u_diff * invSigmaG2);

  // Chain rule for cohesion gradient
  float dG_dU = cohesion * (-2.0 * u_diff * invSigmaG2);
  vec2 cohesionGrad = dG_dU * densityGrad;

  // === ENERGY GRADIENT ===
  vec2 energyGrad = separationGrad - cohesionGrad;

  // === UPDATE POSITION ===
  vec2 newPos = myPos - u_Dt * energyGrad;
  newPos = mod(newPos + u_WorldSize, 2.0 * u_WorldSize) - u_WorldSize;

  // Velocity for visualization
  vec2 velocity = (newPos - myPos) / max(u_DeltaTime, 0.001);

  // Write output
  particlesOut[idx].pos = newPos;
  particlesOut[idx].vel = velocity;
  particlesOut[idx].mass = myMass;
  particlesOut[idx].species = p.species;
  particlesOut[idx].padding = vec2(0.0);
}
