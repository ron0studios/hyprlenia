#version 460 core
/*
 * CHRONOS - Particle-Based Continuous Cellular Automata
 * 
 * This compute shader implements a particle-based extension of Lenia,
 * where discrete particles navigate an energy landscape defined by:
 * 
 *   E(x) = Separation(x) - Cohesion(x)
 * 
 * Particles descend this energy gradient, naturally forming
 * self-organizing structures when parameters are tuned correctly.
 * 
 * The cohesion term creates "sweet spots" of optimal local density,
 * while the separation term prevents overcrowding.
 */

layout(local_size_x = 256) in;

// === PARTICLE DATA STRUCTURE ===
struct Particle {
    vec2 pos;       // World-space position
    vec2 vel;       // Velocity vector (for trails/visualization)
    float mass;     // Vitality/mass [0,1] - determines particle activity
    float species;  // Species identifier for multi-species simulations
    vec2 padding;   // Alignment padding
};

// Double-buffered particle storage
layout(std430, binding = 0) readonly buffer ParticleInput {
    Particle particles[];
};

layout(std430, binding = 1) writeonly buffer ParticleOutput {
    Particle particlesOut[];
};

// === UNIFORMS ===
uniform int u_NumParticles;
uniform float u_Time;
uniform float u_DeltaTime;

// Perception kernel configuration
uniform float u_Wk;        // Kernel magnitude
uniform float u_MuK;       // Peak perception radius
uniform float u_SigmaK2;   // Perception falloff

// Cohesion response (Lenia-inspired growth curve)
uniform float u_MuG;       // Optimal local density
uniform float u_SigmaG2;   // Density tolerance

// Separation behavior
uniform float u_Crep;      // Separation force magnitude

// Temporal
uniform float u_Dt;        // Integration timestep
uniform float u_WorldSize; // Simulation domain half-width

// Finite difference constants for gradient estimation
const float EPSILON = 0.01;
const float EPSILON_2X = 0.02;

// Collision threshold
const float MIN_SEPARATION = 1e-10;

// === PERCEPTION KERNEL ===
// Gaussian-like perception function centered at preferred distance
// Returns how strongly a particle at distance 'r' influences perception
float perceptionKernel(float r) {
    float offset = r - u_MuK;
    return u_Wk * exp(-offset * offset / u_SigmaK2);
}

// === COHESION RESPONSE ===
// Maps local density to a cohesion value
// Peak response at optimal density u_MuG
float cohesionResponse(float localDensity) {
    float offset = localDensity - u_MuG;
    return exp(-offset * offset / u_SigmaG2);
}

// === TOROIDAL WRAPPING ===
// Wraps position to stay within [-size, size] bounds
vec2 toroidalWrap(vec2 p, float size) {
    return mod(p + size, 2.0 * size) - size;
}

// === FIELD COMPUTATION ===
// Computes local density (U) and separation pressure (R) at a sample point
vec2 computeFields(vec2 samplePos, int excludeIdx) {
    float density = 0.0;
    float separation = 0.0;
    
    for (int i = 0; i < u_NumParticles; i++) {
        // Skip inactive particles
        if (particles[i].mass < 0.01) continue;
        
        vec2 offset = toroidalWrap(particles[i].pos - samplePos, u_WorldSize);
        float dist = length(offset);
        
        // Accumulate density from perception kernel
        density += perceptionKernel(dist) * particles[i].mass;
        
        // Accumulate separation pressure (soft repulsion for close neighbors)
        if (i != excludeIdx && dist >= MIN_SEPARATION) {
            float proximity = max(1.0 - dist, 0.0);
            separation += u_Crep * 0.5 * proximity * proximity;
        }
    }
    
    return vec2(density, separation);
}

// === ENERGY LANDSCAPE ===
// Combines all fields into the final energy value particles minimize
vec4 energyLandscape(vec2 samplePos, int excludeIdx) {
    vec2 fields = computeFields(samplePos, excludeIdx);
    float cohesion = cohesionResponse(fields.x);
    float energy = fields.y - cohesion;  // E = Separation - Cohesion
    return vec4(fields.x, fields.y, cohesion, energy);
}

// === GRADIENT ESTIMATION ===
// Finite difference approximation of energy gradient
vec2 estimateEnergyGradient(vec2 pos, int excludeIdx) {
    float ex_pos = energyLandscape(pos + vec2(EPSILON, 0), excludeIdx).w;
    float ex_neg = energyLandscape(pos - vec2(EPSILON, 0), excludeIdx).w;
    float ey_pos = energyLandscape(pos + vec2(0, EPSILON), excludeIdx).w;
    float ey_neg = energyLandscape(pos - vec2(0, EPSILON), excludeIdx).w;
    
    return vec2(
        (ex_pos - ex_neg) / EPSILON_2X,
        (ey_pos - ey_neg) / EPSILON_2X
    );
}

// === MAIN PARTICLE UPDATE ===
void main() {
    uint idx = gl_GlobalInvocationID.x;
    if (idx >= u_NumParticles) return;
    
    Particle p = particles[idx];
    
    // Inactive particles remain unchanged
    if (p.mass < 0.01) {
        particlesOut[idx] = p;
        return;
    }
    
    vec2 currentPos = p.pos;
    
    // Gradient descent on energy landscape
    vec2 gradient = estimateEnergyGradient(currentPos, int(idx));
    vec2 newPos = currentPos - u_Dt * gradient;
    
    // Apply toroidal boundary conditions
    newPos = toroidalWrap(newPos, u_WorldSize);
    
    // Track velocity for visualization purposes
    vec2 velocity = (newPos - currentPos) / max(u_DeltaTime, 0.001);
    
    // Write updated particle state
    particlesOut[idx].pos = newPos;
    particlesOut[idx].vel = velocity;
    particlesOut[idx].mass = p.mass;  // Mass remains constant
    particlesOut[idx].species = p.species;
    particlesOut[idx].padding = vec2(0.0);
}
