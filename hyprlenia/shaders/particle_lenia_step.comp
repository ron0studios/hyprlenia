#version 460 core

 

layout(local_size_x = 128) in;

layout(std430, binding = 0) readonly buffer ParticlesIn {
  float particlesIn[];
};

layout(std430, binding = 1) buffer ParticlesOut { float particlesOut[]; };


layout(rgba16f, binding = 0) uniform image2D u_FoodTexture;


layout(binding = 1) uniform sampler2D u_GoalTexture;
uniform int u_GoalMode;
uniform float u_GoalStrength;


shared vec4 tileData[128];  

uniform int u_NumParticles;
uniform int u_AliveCount;
uniform float u_WorldWidth;
uniform float u_WorldHeight;
uniform float u_WorldDepth;
uniform float u_Wk;       
uniform float u_MuK;      
uniform float u_SigmaK2;  
uniform float u_MuG;      
uniform float u_SigmaG2;  
uniform float u_Crep;     
uniform float u_Dt;       
uniform float u_H;        
uniform bool u_EvolutionEnabled;
uniform float u_BirthRate;
uniform float u_DeathRate;
uniform float u_MutationRate;
uniform float u_EnergyDecay;
uniform float u_EnergyFromGrowth;
uniform int u_RandomSeed;


uniform int u_FoodGridSize;
uniform float u_FoodConsumptionRadius;


ivec2 worldToFoodTexel(vec3 worldPos) {
  vec2 uv = (worldPos.xy + vec2(u_WorldWidth, u_WorldHeight) * 0.5) /
            vec2(u_WorldWidth, u_WorldHeight);
  uv = clamp(uv, 0.0, 0.999);
  return ivec2(uv * float(u_FoodGridSize));
}


float consumeFood(vec3 worldPos, float maxConsume) {
  ivec2 texel = worldToFoodTexel(worldPos);
  vec4 food = imageLoad(u_FoodTexture, texel);
  float available = food.r;
  float consumed = min(available, maxConsume);

  if (consumed > 0.001) {
    food.r = available - consumed;
    imageStore(u_FoodTexture, texel, food);
  }

  return consumed;
}


float sampleFood(vec3 worldPos) {
  ivec2 texel = worldToFoodTexel(worldPos);
  return imageLoad(u_FoodTexture, texel).r;
}


vec3 wrappedDelta(vec3 from, vec3 to) {
  vec3 d = to - from;
  float halfW = u_WorldWidth * 0.5;
  float halfH = u_WorldHeight * 0.5;
  float halfD = u_WorldDepth * 0.5;

  if (d.x > halfW)
    d.x -= u_WorldWidth;
  else if (d.x < -halfW)
    d.x += u_WorldWidth;

  if (d.y > halfH)
    d.y -= u_WorldHeight;
  else if (d.y < -halfH)
    d.y += u_WorldHeight;

  if (d.z > halfD)
    d.z -= u_WorldDepth;
  else if (d.z < -halfD)
    d.z += u_WorldDepth;

  return d;
}

vec3 wrapPos(vec3 pos) {
  float halfW = u_WorldWidth * 0.5;
  float halfH = u_WorldHeight * 0.5;
  float halfD = u_WorldDepth * 0.5;

  pos.x = mod(pos.x + halfW, u_WorldWidth) - halfW;
  pos.y = mod(pos.y + halfH, u_WorldHeight) - halfH;
  pos.z = mod(pos.z + halfD, u_WorldDepth) - halfD;

  return pos;
}

float hash(int seed) {
  int x = seed;
  x = ((x >> 16) ^ x) * 0x45d9f3b;
  x = ((x >> 16) ^ x) * 0x45d9f3b;
  x = (x >> 16) ^ x;
  return float(x & 0x7FFFFFFF) / float(0x7FFFFFFF);
}

float random(int idx, int offset) {
  return hash(idx * 1337 + offset * 7919 + u_RandomSeed * 104729);
}


float kernelK(float r) {
  float diff = r - u_MuK;
  return u_Wk * exp(-diff * diff / u_SigmaK2);
}


vec2 computeUR(vec3 queryPos, int tileEnd) {
  float U = 0.0;
  float R = 0.0;

  for (int j = 0; j < tileEnd; j++) {
    float otherEnergy = tileData[j].w;
    if (otherEnergy < 0.01) continue;

    vec3 otherPos = tileData[j].xyz;
    vec3 delta = wrappedDelta(queryPos, otherPos);
    float dist = length(delta);

    
    U += kernelK(dist);

    
    if (dist > 0.0001 && dist < 1.0) {
      float proximity = 1.0 - dist;
      R += 0.5 * u_Crep * proximity * proximity;
    }
  }

  return vec2(U, R);
}


float computeE(float U, float R) {
  float diff = U - u_MuG;
  float G = exp(-diff * diff / u_SigmaG2);
  return R - G;
}

void main() {
  uint idx = gl_GlobalInvocationID.x;
  uint localIdx = gl_LocalInvocationID.x;

  if (idx >= u_NumParticles) return;

  int i = int(idx);
  int base = i * 15;  

  
  vec3 myPos =
      vec3(particlesIn[base], particlesIn[base + 1], particlesIn[base + 2]);
  vec3 myVel =
      vec3(particlesIn[base + 3], particlesIn[base + 4], particlesIn[base + 5]);
  float myEnergy = particlesIn[base + 6];
  float mySpecies = particlesIn[base + 7];
  float myAge = particlesIn[base + 8];
  float myDna[5];
  for (int d = 0; d < 5; d++) {
    myDna[d] = particlesIn[base + 9 + d];
  }

  
  if (myEnergy < 0.01) {
    for (int j = 0; j < 15; j++) {
      particlesOut[base + j] = particlesIn[base + j];
    }
    return;
  }

  
  float h = u_H;
  vec3 posXp = myPos + vec3(h, 0.0, 0.0);
  vec3 posXn = myPos - vec3(h, 0.0, 0.0);
  vec3 posYp = myPos + vec3(0.0, h, 0.0);
  vec3 posYn = myPos - vec3(0.0, h, 0.0);
  vec3 posZp = myPos + vec3(0.0, 0.0, h);
  vec3 posZn = myPos - vec3(0.0, 0.0, h);

  
  vec2 UR_c = vec2(0.0);   
  vec2 UR_xp = vec2(0.0);  
  vec2 UR_xn = vec2(0.0);  
  vec2 UR_yp = vec2(0.0);  
  vec2 UR_yn = vec2(0.0);  
  vec2 UR_zp = vec2(0.0);  
  vec2 UR_zn = vec2(0.0);  

  int numTiles = (u_NumParticles + 127) / 128;

  for (int t = 0; t < numTiles; t++) {
    
    int loadIdx = t * 128 + int(localIdx);
    if (loadIdx < u_NumParticles) {
      int loadBase = loadIdx * 15;
      tileData[localIdx] = vec4(particlesIn[loadBase],       
                                particlesIn[loadBase + 1],   
                                particlesIn[loadBase + 2],   
                                particlesIn[loadBase + 6]);  
    } else {
      tileData[localIdx] = vec4(0.0);
    }

    barrier();

    int tileEnd = min(128, u_NumParticles - t * 128);

    
    UR_c += computeUR(myPos, tileEnd);
    UR_xp += computeUR(posXp, tileEnd);
    UR_xn += computeUR(posXn, tileEnd);
    UR_yp += computeUR(posYp, tileEnd);
    UR_yn += computeUR(posYn, tileEnd);
    UR_zp += computeUR(posZp, tileEnd);
    UR_zn += computeUR(posZn, tileEnd);

    barrier();
  }

  
  float E_xp = computeE(UR_xp.x, UR_xp.y);
  float E_xn = computeE(UR_xn.x, UR_xn.y);
  float E_yp = computeE(UR_yp.x, UR_yp.y);
  float E_yn = computeE(UR_yn.x, UR_yn.y);
  float E_zp = computeE(UR_zp.x, UR_zp.y);
  float E_zn = computeE(UR_zn.x, UR_zn.y);

  
  float h2 = 2.0 * h;
  vec3 gradE = vec3((E_xp - E_xn) / h2, (E_yp - E_yn) / h2, (E_zp - E_zn) / h2);

  
  float diff = UR_c.x - u_MuG;
  float growth = exp(-diff * diff / u_SigmaG2);

  
  vec3 newPos = myPos - u_Dt * gradE;

  
  if (u_GoalMode > 0 && u_GoalStrength > 0.001) {
    
    vec2 uv = (myPos.xy + vec2(u_WorldWidth, u_WorldHeight) * 0.5) /
              vec2(u_WorldWidth, u_WorldHeight);

    
    float eps = 0.01;
    float valC = texture(u_GoalTexture, uv).r;
    float valR = texture(u_GoalTexture, uv + vec2(eps, 0.0)).r;
    float valL = texture(u_GoalTexture, uv - vec2(eps, 0.0)).r;
    float valT = texture(u_GoalTexture, uv + vec2(0.0, eps)).r;
    float valB = texture(u_GoalTexture, uv - vec2(0.0, eps)).r;

    vec2 grad = vec2(valR - valL, valT - valB) / (2.0 * eps);

    
    float gradLen = length(grad);
    if (gradLen > 1.0) grad = normalize(grad);

    
    
    vec2 force = grad * u_GoalStrength * u_Dt * 1.5;

    
    
    if (valC < 0.5) {
      float agitation =
          (1.0 - valC) * u_GoalStrength * u_Dt * 5.0;  
      float r1 = random(int(idx), 100 + u_RandomSeed) * 2.0 - 1.0;
      float r2 = random(int(idx), 101 + u_RandomSeed) * 2.0 - 1.0;
      force += vec2(r1, r2) * agitation;
    }

    newPos.xy += force;
  }

  newPos = wrapPos(newPos);

  
  myVel = (newPos - myPos) / max(u_Dt, 0.001);
  myPos = newPos;
  myAge += 1.0;

  
  if (u_EvolutionEnabled) {
    
    float foodConsumed = consumeFood(myPos, u_EnergyFromGrowth * 0.5);

    
    float clusterBonus = growth * 0.3;
    float energyGain = foodConsumed * (1.0 + clusterBonus);

    
    float energyLoss = u_EnergyDecay;

    
    
    if (u_GoalMode > 0 && u_GoalStrength > 0.001) {
      vec2 uv = (myPos.xy + vec2(u_WorldWidth, u_WorldHeight) * 0.5) /
                vec2(u_WorldWidth, u_WorldHeight);
      if (uv.x >= 0.0 && uv.x <= 1.0 && uv.y >= 0.0 && uv.y <= 1.0) {
        float goalVal = texture(u_GoalTexture, uv).r;
        
        float penalty = pow(1.0 - goalVal, 2.0) * 0.05 * u_GoalStrength;
        energyLoss += penalty;
      }
    }

    
    if (myAge > 3000.0) {
      energyLoss += u_DeathRate * 0.05 * (myAge - 3000.0) / 3000.0;
    }

    
    if (growth < 0.2) {
      energyLoss += u_EnergyDecay * 0.5;
    }

    
    myEnergy = clamp(myEnergy + energyGain - energyLoss, 0.0, 1.0);

    
    if (myEnergy < 0.001) {
      myEnergy = 0.0;
    }

    
    if (myEnergy > 0.80 && foodConsumed > 0.001) {
      float reproChance =
          (myEnergy - 0.80) * 0.5 * min(foodConsumed * 10.0, 1.0);

      if (random(i, 1) < reproChance) {
        for (int j = 0; j < u_NumParticles; j++) {
          float otherE = particlesIn[j * 15 + 6];
          if (otherE < 0.01) {
            int childBase = j * 15;

            
            float theta = random(i, 2) * 6.28318;        
            float phi = acos(2.0 * random(i, 3) - 1.0);  
            float spawnDist = 0.5 + random(i, 4) * 0.5;

            vec3 spawnDir =
                vec3(sin(phi) * cos(theta), sin(phi) * sin(theta), cos(phi));
            vec3 childPos = wrapPos(myPos + spawnDir * spawnDist);

            particlesOut[childBase + 0] = childPos.x;
            particlesOut[childBase + 1] = childPos.y;
            particlesOut[childBase + 2] = childPos.z;
            particlesOut[childBase + 3] = myVel.x * 0.5;
            particlesOut[childBase + 4] = myVel.y * 0.5;
            particlesOut[childBase + 5] = myVel.z * 0.5;
            particlesOut[childBase + 6] = 0.35;
            particlesOut[childBase + 7] =
                mySpecies + (random(i, 5) - 0.5) * 0.1;
            particlesOut[childBase + 8] = 0.0;

            for (int d = 0; d < 5; d++) {
              float mut = (random(i, 6 + d) - 0.5) * u_MutationRate;
              particlesOut[childBase + 9 + d] =
                  clamp(myDna[d] + mut, -0.5, 0.5);
            }
            particlesOut[childBase + 14] = 0.0;  

            myEnergy -= 0.35;
            break;
          }
        }
      }
    }
  }

  
  particlesOut[base + 0] = myPos.x;
  particlesOut[base + 1] = myPos.y;
  particlesOut[base + 2] = myPos.z;
  particlesOut[base + 3] = myVel.x;
  particlesOut[base + 4] = myVel.y;
  particlesOut[base + 5] = myVel.z;
  particlesOut[base + 6] = myEnergy;
  particlesOut[base + 7] = mySpecies;
  particlesOut[base + 8] = myAge;
  for (int d = 0; d < 5; d++) {
    particlesOut[base + 9 + d] = myDna[d];
  }
  particlesOut[base + 14] = UR_c.x;  
}
