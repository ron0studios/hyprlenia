#version 460 core

 

layout(local_size_x = 256) in;

struct Particle {
  vec2 position;
  vec2 velocity;
  float energy;
  float mass;
  float padding1;
  float padding2;
};

layout(std430, binding = 0) buffer ParticlesIn { Particle particlesIn[]; };

layout(std430, binding = 1) buffer ParticlesOut { Particle particlesOut[]; };

uniform int u_NumParticles;
uniform float u_DeltaTime;
uniform bool u_EnableEvolution;

uniform vec2 u_WorldMin;
uniform vec2 u_WorldMax;


uniform float u_Mu_k;     
uniform float u_Sigma_k;  
uniform float u_W_k;      
uniform float u_Mu_g;     
uniform float u_Sigma_g;  
uniform float u_C_rep;    


uniform float u_EnergyDecay;
uniform float u_EnergyFromGrowth;
uniform float u_BaseEnergy;


float gaussianKernel(float r) {
  float diff = r - u_Mu_k;
  return exp(-0.5 * (diff * diff) / (u_Sigma_k * u_Sigma_k));
}



float growthFunction(float u) {
  float diff = u - u_Mu_g;
  return 2.0 * exp(-0.5 * (diff * diff) / (u_Sigma_g * u_Sigma_g)) - 1.0;
}



float fitnessFunction(float u) {
  float diff = u - u_Mu_g;
  return exp(-0.5 * (diff * diff) / (u_Sigma_g * u_Sigma_g));
}


vec2 wrapPosition(vec2 pos) {
  vec2 size = u_WorldMax - u_WorldMin;
  return u_WorldMin + mod(pos - u_WorldMin + size, size);
}


vec2 wrappedDelta(vec2 from, vec2 to) {
  vec2 size = u_WorldMax - u_WorldMin;
  vec2 d = to - from;
  if (d.x > size.x * 0.5)
    d.x -= size.x;
  else if (d.x < -size.x * 0.5)
    d.x += size.x;
  if (d.y > size.y * 0.5)
    d.y -= size.y;
  else if (d.y < -size.y * 0.5)
    d.y += size.y;
  return d;
}

void main() {
  uint idx = gl_GlobalInvocationID.x;

  if (idx >= uint(u_NumParticles)) return;

  Particle me = particlesIn[idx];

  
  if (me.energy < 0.001) {
    particlesOut[idx] = me;
    return;
  }

  vec2 force = vec2(0.0);
  float fieldSum = 0.0;
  float totalWeight = 0.0;

  float maxDist = u_Mu_k + 3.0 * u_Sigma_k;

  
  for (int j = 0; j < u_NumParticles; j++) {
    if (j == int(idx)) continue;

    Particle other = particlesIn[j];
    if (other.energy < 0.001) continue;

    vec2 delta = wrappedDelta(me.position, other.position);
    float dist = length(delta);

    if (dist > maxDist || dist < 0.0001) continue;

    vec2 dir = delta / dist;
    float kernel = gaussianKernel(dist);
    float weightedKernel = kernel * other.mass;

    fieldSum += weightedKernel;
    totalWeight += other.mass;

    
    float attraction = u_W_k * weightedKernel;

    
    float repulsion = u_C_rep * exp(-dist * 10.0);

    force += (attraction - repulsion) * dir;
  }

  
  float growth = 0.0;
  float fitness = 0.0;
  float neighborCount = 0.0;

  if (totalWeight > 0.0) {
    float u = fieldSum / totalWeight;
    growth = growthFunction(u);
    fitness = fitnessFunction(u);
    neighborCount = totalWeight;
  }

  
  force += growth * 0.1;

  
  vec2 newVelocity = me.velocity + force * u_DeltaTime;
  newVelocity *= 0.98;  

  vec2 newPosition = me.position + newVelocity * u_DeltaTime;
  newPosition = wrapPosition(newPosition);

  
  float newEnergy = me.energy;

  if (u_EnableEvolution) {
    
    
    

    bool hasNeighbors = (neighborCount > 0.1);

    if (hasNeighbors) {
      
      
      float neighborBonus = min(neighborCount, 3.0) / 3.0;  
      float energyGain = neighborBonus * u_EnergyFromGrowth;

      
      float energyLoss = u_EnergyDecay * 0.05;

      newEnergy = me.energy + energyGain - energyLoss;
    } else {
      
      
      newEnergy = me.energy - u_EnergyDecay;
    }

    
    newEnergy = clamp(newEnergy, 0.0, 2.0);
  }

  
  Particle result;
  result.position = newPosition;
  result.velocity = newVelocity;
  result.energy = newEnergy;
  result.mass = me.mass;
  result.padding1 = 0.0;
  result.padding2 = 0.0;

  particlesOut[idx] = result;
}
